name: test
on:
  workflow_run:
    workflows: ["review", "auto-approve"]
    types:
      - completed

permissions: {}

env: 
  BUCKET: ${{ secrets.BUCKET }}
  DEPLOYMENT_ROLE: ${{ secrets.DEPLOYMENT_ROLE }}
  PROJECT_NAME: ${{ github.event.repository.name }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  check-build-status:
    runs-on: ubuntu-latest
    outputs:
      skip_cloudformation: ${{ steps.check.outputs.skip_cf }}
    steps:
      - uses: actions/github-script@v7
        id: check
        with:
          script: |
            const jobsUrl = context.payload.workflow_run.jobs_url;
            const jobsResp = await github.request(`GET ${jobsUrl}`);
            const jobs = jobsResp.data.jobs;

            const filterJob = jobs.find(j => j.name === 'build/filter');
            const buildJob = jobs.find(j => j.name === 'build/build');

            let skip_cf = false;

            // Check if filter job determined that build should not run
            // In this case, build job runs but skips all steps
            if (filterJob?.conclusion === 'success' && buildJob?.conclusion === 'success') {
              // Look for the filter job's output in its steps
              const filterSteps = filterJob.steps || [];
              const checkStep = filterSteps.find(s => s.name === 'Decide if only ignored paths changed');
              
              // If we can't determine from steps, check if build job has a "Check if build should run" step
              const buildSteps = buildJob.steps || [];
              const shouldBuildStep = buildSteps.find(s => s.name === 'Check if build should run');
              
              // If the "Check if build should run" step exists and completed, 
              // but no subsequent build steps ran, then we should skip CloudFormation
              if (shouldBuildStep?.conclusion === 'success') {
                const checkoutStep = buildSteps.find(s => s.name === 'Checkout code');
                if (checkoutStep?.conclusion === 'skipped') {
                  skip_cf = true;
                }
              }
            }

            core.setOutput('skip_cf', skip_cf ? 'true' : 'false');

  deployment:
    if: github.event.workflow_run.conclusion == 'success'

    runs-on: ubuntu-latest

    permissions:
      contents: read
      deployments: write

    outputs:
      PR_SHA: ${{ steps.set-build-data.outputs.pr_sha }}
      BUILD_RUN_ID: ${{ steps.set-build-data.outputs.build_run_id }}
      DEPLOYMENT_ID: ${{ steps.create-deployment.outputs.deployment_id }}

    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      ENVIRONMENT: AWS

    steps:
      - name: Get run data
        uses: actions/download-artifact@v4
        with:
          name: BuildDataArtifact
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Set build data
        id: set-build-data
        run: |
          BUILD_RUN_ID=$(grep '^run_id=' builddata.txt | cut -d'=' -f2)
          echo "build_run_id=$BUILD_RUN_ID" >> $GITHUB_OUTPUT
          echo $BUILD_RUN_ID
          PR_SHA=$(grep '^sha=' builddata.txt | cut -d'=' -f2)
          echo "pr_sha=$PR_SHA" >> $GITHUB_OUTPUT
          echo $PR_SHA

      - name: Create Deployment
        id: create-deployment
        run: |
          DEPLOYMENT_ID=$(gh api repos/${{ github.repository }}/deployments \
            -f ref=${{ steps.set-build-data.outputs.pr_sha }} \
            -f environment=$ENVIRONMENT \
            -F auto_merge=false \
            --jq '.id')

          echo DEPLOYMENT_ID: $DEPLOYMENT_ID
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
  
  test:
    runs-on: ubuntu-latest
    needs: [ deployment, check-build-status ]
    if: ${{ needs.check-build-status.outputs.skip_cloudformation }} == 'false'
    
    environment: AWS

    permissions:
      actions: read
      checks: read
      contents: read
      id-token: write

    outputs:
      CHANGE_SET: ${{ steps.changeset.outputs.CHANGE_SET }}
      STACK_NAME: ${{ steps.changeset.outputs.STACK_NAME }}
      STACK_EXISTS: ${{ steps.changeset.outputs.STACK_EXISTS }}
      DATE: ${{ steps.s3.outputs.DATE }}
      S3_STATUS: ${{ steps.s3.outcome }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0     
        with:
          role-to-assume: ${{ env.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: true

      - name: Additional steps
        run: |
          aws sts get-caller-identity 
          
      - name: Get workshop content
        uses: actions/download-artifact@v4
        with:
          name: ContentArtifact
          github-token: ${{ github.token }}
          run-id: ${{ needs.deployment.outputs.BUILD_RUN_ID }}

      - name: Upload to S3
        id: s3
        run: |
          date=$(date --utc +"%Y-%m-%dT%H-%M-%SZ")
          echo "DATE=$date" >> $GITHUB_OUTPUT
          mkdir -p ${{ github.workspace }}/content
          unzip content.zip -d ${{ github.workspace }}/content
          aws s3 cp ${{ github.workspace }}/content s3://$BUCKET/$date/ --recursive

      - name: Deploy change set
        id: changeset
        run: |
          date=${{ steps.s3.outputs.DATE }}
          set +e
          aws cloudformation describe-stacks --stack-name $PROJECT_NAME --region $AWS_REGION >/dev/null 2>&1
          EXITCODE=$?
          set -e
          
          if [[ $EXITCODE -eq 0 ]]; then
            echo "Stack exists - creating UPDATE change set"
            STACK_EXISTS=true
            CHANGE_SET_TYPE=UPDATE
          else
            echo "Stack does not exist - creating CREATE change set"
            STACK_EXISTS=false
            CHANGE_SET_TYPE=CREATE
          fi
          
          aws cloudformation create-change-set \
            --change-set-type $CHANGE_SET_TYPE \
            --stack-name $PROJECT_NAME \
            --change-set-name $PROJECT_NAME-$date \
            --template-url https://$BUCKET.s3.amazonaws.com/$date/$PROJECT_NAME.template \
            --parameters \
              ParameterKey=AssetsBucketName,ParameterValue=$BUCKET \
              ParameterKey=AssetsBucketPrefix,ParameterValue="${date}/" \
              ParameterKey=ParticipantRoleName,ParameterValue=Admin \
            --capabilities CAPABILITY_IAM \
            --region $AWS_REGION
          
          echo "Waiting for change set to be created..."
          aws cloudformation wait change-set-create-complete \
            --stack-name $PROJECT_NAME \
            --change-set-name $PROJECT_NAME-$date \
            --region $AWS_REGION
          
          echo "Executing change set..."
          aws cloudformation execute-change-set \
            --stack-name $PROJECT_NAME \
            --change-set-name $PROJECT_NAME-$date \
            --region $AWS_REGION
          
          echo "CHANGE_SET=$PROJECT_NAME-$date" >> "$GITHUB_OUTPUT"
          echo "STACK_NAME=$PROJECT_NAME" >> "$GITHUB_OUTPUT"
          echo "STACK_EXISTS=$STACK_EXISTS" >> "$GITHUB_OUTPUT"
    
    
  wait_for_stack:
      runs-on: ubuntu-latest
      needs: [ test ]
      if: ${{ needs.test.result}} == 'success'
      
      environment: AWS
      
      permissions:
        id-token: write

      env:
        STACK_NAME: ${{ needs.test.outputs.STACK_NAME }}
        STACK_EXISTS: ${{ needs.test.outputs.STACK_EXISTS }}
        
      steps:
        - name: Configure AWS Credentials
          uses: aws-actions/configure-aws-credentials@v5.1.0     
          with:
            role-to-assume: ${{ env.DEPLOYMENT_ROLE }}
            aws-region: ${{ env.AWS_REGION }}
            mask-aws-account-id: true
  
        - name: Additional steps
          run: |
            aws sts get-caller-identity 

        - name: Wait for CloudFormation Stack to complete
          run: |
            if [[ "$STACK_EXISTS" == "true" ]]; then
              echo "Waiting for stack UPDATE to complete..."
              aws cloudformation wait stack-update-complete \
                --stack-name "$STACK_NAME" \
                --region $AWS_REGION
              echo "Stack update completed successfully"
            else
              echo "Waiting for stack CREATE to complete..."
              aws cloudformation wait stack-create-complete \
                --stack-name "$STACK_NAME" \
                --region $AWS_REGION
              echo "Stack creation completed successfully"
            fi
          
  cleanup:
    runs-on: ubuntu-latest
    
    environment: AWS

    permissions:
      id-token: write
   
    needs: [ wait_for_stack, test ]
    
    if: ${{ always() && needs.test.outputs.S3_STATUS == 'success' }}
    
    env:
      DATE: ${{ needs.test.outputs.DATE }}
    
    steps:   
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0  
        with:
          role-to-assume: ${{ env.DEPLOYMENT_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: true

      - name: Additional steps
        run: |
          aws sts get-caller-identity 
          
      - name: Cleanup Old S3 Content
        if: ${{ needs.wait_for_stack.result == 'success' }}
        run: |
          echo Deleting old S3 content due to deployment success
          aws s3 rm s3://$BUCKET/ --recursive --exclude "$DATE/*"
      
      - name: Cleanup New S3 Content
        if: ${{ needs.wait_for_stack.result != 'success' }}
        run: |
          echo Deleting new S3 content because deployment did not succeed
          aws s3 rm s3://$BUCKET/ --recursive --exclude "*" --include "$DATE/*"

  report:
    runs-on: ubuntu-latest  
    needs: [ cleanup, wait_for_stack, deployment, check-build-status ]
    
    if: ${{ always() && needs.deployment.result == 'success' }}

    permissions:
      deployments: write

    steps:
      - name: Set stack status
        id: stack_status
        run: |
          if [[ "${{ needs.wait_for_stack.result }}" != "skipped" ]]; then
            echo "STACK_STATUS=${{ needs.wait_for_stack.result }}" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.check-build-status.outputs.skip_cloudformation }}" == "true" ]]; then
            echo "STACK_STATUS=success" >> $GITHUB_OUTPUT
          else
            echo "STACK_STATUS=failure" >> $GITHUB_OUTPUT

      - name: Report deployment status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo DEPLOYMENT ID: ${{ needs.deployment.outputs.DEPLOYMENT_ID }}
          gh api repos/${{ github.repository }}/deployments/${{ needs.deployment.outputs.DEPLOYMENT_ID }}/statuses -f "state=${{ steps.stack_status.outputs.STACK_STATUS }}"