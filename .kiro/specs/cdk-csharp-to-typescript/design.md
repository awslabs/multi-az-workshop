# Design Document: CDK C# to TypeScript Conversion

## Overview

This design document outlines the approach for converting the Multi-AZ Workshop CDK project from C# to TypeScript. The conversion will maintain functional equivalence while adopting TypeScript idioms and leveraging Projen for project management. The project consists of a main stack, 13 custom constructs, 15 nested stacks, and supporting Lambda functions.

### Goals

1. Achieve 100% functional equivalence with the C# implementation
2. Follow TypeScript and CDK best practices
3. Use Projen for automated project configuration management
4. Create local build scripts that mirror GitHub CI/CD workflows
5. Maintain clear, well-documented code for future maintainers

### Non-Goals

1. Changing the deployed AWS infrastructure architecture
2. Upgrading CDK library versions beyond what's in the C# project
3. Refactoring business logic or architectural patterns
4. Modifying Lambda function source code (Python)

## Architecture

### Project Structure

```
cdk/
├── bin/
│   └── multi-az-workshop.ts          # CDK app entry point
├── lib/
│   ├── multi-az-workshop-stack.ts    # Main stack
│   ├── constructs/                    # Custom constructs (13 files)
│   │   ├── aws-load-balancer-controller.ts
│   │   ├── container-and-repo.ts
│   │   ├── eks-application.ts
│   │   ├── eks-cluster.ts
│   │   ├── enhanced-load-balancer.ts
│   │   ├── helm-repo-and-chart.ts
│   │   ├── ip-address-type.ts
│   │   ├── istio.ts
│   │   ├── load-balancer-zonal-dns-records.ts
│   │   ├── nested-stack-with-source.ts
│   │   ├── network-builder.ts
│   │   ├── operation-log-queries.ts
│   │   └── vpc-ipv6-construct.ts
│   ├── nested-stacks/                 # Nested stacks (15 files)
│   │   ├── application-recovery-controller-stack.ts
│   │   ├── application-stack.ts
│   │   ├── az-tagger-stack.ts
│   │   ├── code-deploy-application-stack.ts
│   │   ├── database-stack.ts
│   │   ├── ec2-fleet-stack.ts
│   │   ├── eks-stack.ts
│   │   ├── fault-injection-stack.ts
│   │   ├── ipv6-network-stack.ts
│   │   ├── log-query-stack.ts
│   │   ├── route53-health-checks-stack.ts
│   │   ├── route53-zonal-dns-stack.ts
│   │   ├── self-managed-http-endpoint-apig-stack.ts
│   │   ├── self-managed-http-endpoint-s3-stack.ts
│   │   └── ssm-random-fault-stack.ts
│   ├── types/                         # Type definitions
│   │   ├── evacuation-method.ts
│   │   └── index.ts
│   └── utils/                         # Utility functions
│       └── service-factory.ts
├── configs/                           # Configuration files (unchanged)
├── az-tagger-src/                     # Lambda source (unchanged)
├── uploader-src/                      # Lambda source (unchanged)
├── layer/                             # Lambda layers (generated)
├── .projenrc.ts                       # Projen configuration
├── package.json                       # Generated by Projen
├── tsconfig.json                      # Generated by Projen
├── cdk.json                           # CDK configuration
└── README.md                          # Project documentation
```

### Technology Stack

- **Language**: TypeScript 5.x
- **CDK Version**: 2.189.1 (matching C# version)
- **Node.js**: 20.x LTS
- **Package Manager**: npm
- **Project Management**: Projen
- **Build Tool**: TypeScript compiler (tsc)
- **Testing Framework**: Jest (configured by Projen)
- **Linting**: ESLint (configured by Projen)

## Components and Interfaces

### 1. Main Application Entry Point

**File**: `bin/multi-az-workshop.ts`

**Purpose**: Initialize the CDK app and instantiate the main stack

**Key Elements**:
- Import CDK App class
- Create App instance
- Instantiate MultiAZWorkshopStack with proper configuration
- Call app.synth()

**C# to TypeScript Mapping**:
```csharp
// C# (Program.cs)
var app = new App();
MultiAZWorkshopStack multiAZWorkshop = new MultiAZWorkshopStack(app, "multi-az-workshop", new StackProps(){...});
app.Synth();
```

```typescript
// TypeScript (bin/multi-az-workshop.ts)
const app = new cdk.App();
new MultiAZWorkshopStack(app, 'multi-az-workshop', {
  stackName: 'multi-az-workshop',
  env: { region: process.env.CDK_DEFAULT_REGION },
  synthesizer: new cdk.DefaultStackSynthesizer({...})
});
app.synth();
```

### 2. Main Stack

**File**: `lib/multi-az-workshop-stack.ts`

**Purpose**: Define the primary CloudFormation stack with all resources

**Key Responsibilities**:
- Define CloudFormation parameters
- Create VPC and networking resources
- Instantiate nested stacks
- Configure observability and monitoring
- Set up load balancers and target groups
- Create service definitions

**Interface**:
```typescript
export interface MultiAZWorkshopStackProps extends cdk.StackProps {
  // Inherits standard stack props
}

export class MultiAZWorkshopStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: MultiAZWorkshopStackProps);
}
```

### 3. Custom Constructs

Each construct will follow this pattern:

**Interface Pattern**:
```typescript
export interface <ConstructName>Props {
  // Required properties
  requiredProp: Type;
  
  // Optional properties
  optionalProp?: Type;
}

export class <ConstructName> extends Construct {
  // Public readonly properties for outputs
  public readonly outputProperty: Type;
  
  constructor(scope: Construct, id: string, props: <ConstructName>Props) {
    super(scope, id);
    // Implementation
  }
}
```

**Key Constructs**:

1. **EKSCluster**: Creates and configures an EKS cluster
2. **EnhancedLoadBalancer**: Extends ALB with zonal shift capabilities
3. **NetworkBuilder**: Constructs VPC with IPv6 support
4. **Istio**: Deploys Istio service mesh components
5. **AwsLoadBalancerController**: Installs AWS LB controller on EKS

### 4. Nested Stacks

Each nested stack will follow this pattern:

**Interface Pattern**:
```typescript
export interface <StackName>Props extends cdk.NestedStackProps {
  // Stack-specific properties
}

export class <StackName> extends cdk.NestedStack {
  // Public outputs
  public readonly output: Type;
  
  constructor(scope: Construct, id: string, props: <StackName>Props) {
    super(scope, id, props);
    // Implementation
  }
}
```

**Key Nested Stacks**:

1. **IpV6NetworkStack**: VPC with IPv6 support
2. **DatabaseStack**: Aurora database cluster
3. **EC2FleetStack**: Auto-scaling group with launch template
4. **EKSStack**: EKS cluster and node groups
5. **CodeDeployApplicationStack**: CodeDeploy configuration
6. **FaultInjectionStack**: AWS FIS experiments
7. **Route53ZonalDnsStack**: Zonal DNS records
8. **LogQueryStack**: CloudWatch Insights queries

### 5. Type Definitions

**File**: `lib/types/evacuation-method.ts`

```typescript
export enum EvacuationMethod {
  ZONAL_SHIFT = 'ZonalShift',
  ARC = 'ARC',
  SELF_MANAGED_HTTP_ENDPOINT_APIG = 'SelfManagedHttpEndpoint_APIG',
  SELF_MANAGED_HTTP_ENDPOINT_S3 = 'SelfManagedHttpEndpoint_S3'
}
```

### 6. Service Factory

**File**: `lib/utils/service-factory.ts`

**Purpose**: Create the service definition with operations (extracted from main stack)

**Interface**:
```typescript
export interface CreateServiceOptions {
  loadBalancer: elbv2.ILoadBalancerV2;
  vpc: ec2.IVpc;
  serverLogGroups: logs.ILogGroup[];
  targetGroups?: elbv2.IApplicationTargetGroup[];
}

export function createService(options: CreateServiceOptions): IService {
  // Implementation
}
```

## Data Models

### CloudFormation Parameters

```typescript
interface StackParameters {
  assetsBucketName: cdk.CfnParameter;
  assetsBucketPrefix: cdk.CfnParameter;
  participantRoleName: cdk.CfnParameter;
}
```

### Availability Zone Configuration

```typescript
interface AvailabilityZoneConfig {
  availabilityZoneNames: string[];
  availabilityZoneIds: string[];
  availabilityZoneMap: Record<string, string>;
}
```

### Service Configuration

```typescript
interface ServiceConfig {
  serviceName: string;
  baseUrl: string;
  faultCountThreshold: number;
  availabilityZoneNames: string[];
  period: cdk.Duration;
  loadBalancer: elbv2.ILoadBalancerV2;
  targetGroups?: elbv2.IApplicationTargetGroup[];
}
```

## Projen Configuration

### .projenrc.ts Structure

```typescript
import { awscdk } from 'projen';

const project = new awscdk.AwsCdkTypeScriptApp({
  cdkVersion: '2.189.1',
  defaultReleaseBranch: 'main',
  name: 'multi-az-workshop-cdk',
  projenrcTs: true,
  
  // Dependencies
  deps: [
    'cdklabs.multi-az-observability@0.0.1-alpha.60',
    '@aws-cdk/lambda-layer-kubectl-v31@^2.0.0',
  ],
  
  // Dev dependencies
  devDeps: [
    '@types/node',
  ],
  
  // TypeScript configuration
  tsconfig: {
    compilerOptions: {
      target: 'ES2020',
      module: 'commonjs',
      lib: ['ES2020'],
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
    },
  },
  
  // ESLint configuration
  eslint: true,
  prettier: true,
  
  // Jest configuration
  jest: true,
  jestOptions: {
    jestConfig: {
      testMatch: ['**/*.test.ts'],
      coverageDirectory: 'coverage',
    },
  },
  
  // GitHub workflows
  buildWorkflow: true,
  release: false,
  
  // CDK-specific
  cdkout: 'cdk.out',
  context: {
    '@aws-cdk/core:newStyleStackSynthesis': true,
  },
  
  // Custom scripts
  scripts: {
    'build:app': 'scripts/build-app.sh',
    'build:assets': 'scripts/build-assets.sh',
    'build:containers': 'scripts/build-containers.sh',
    'build:full': 'npm run build:app && npm run build:assets && npm run build:containers',
    'lint:fix': 'eslint . --ext .ts --fix',
    'test:unit': 'jest --coverage',
    'synth:local': 'cdk synth',
    'deploy:local': 'cdk deploy',
  },
});

project.synth();
```

### Custom NPX Scripts

Scripts will be added to mirror GitHub workflows:

1. **build:app** - Build the .NET application
2. **build:assets** - Download and package external assets (Helm charts, container images)
3. **build:containers** - Build Docker containers
4. **build:full** - Run complete build pipeline
5. **lint** - Run ESLint
6. **test** - Run Jest tests
7. **synth** - Synthesize CloudFormation templates
8. **deploy** - Deploy to AWS

## Error Handling

### Type Safety

- Use strict TypeScript compilation
- Define explicit interfaces for all props
- Use type guards for runtime validation
- Leverage CDK's built-in validation

### Resource Dependencies

```typescript
// Explicit dependency declaration
resourceB.node.addDependency(resourceA);

// Conditional resource creation
if (evacuationMethod !== EvacuationMethod.ZONAL_SHIFT) {
  this.route53Stack = new Route53ZonalDnsStack(this, 'route-53-', {
    // props
  });
}
```

### Asset Path Resolution

```typescript
import * as path from 'path';

// Resolve paths relative to project root
const configPath = path.join(__dirname, '..', 'configs', 'cw-agent-config.json');
const lambdaPath = path.join(__dirname, '..', 'az-tagger-src');
```

## Testing Strategy

### Unit Tests

**Scope**: Test individual constructs and stacks in isolation

**Approach**:
```typescript
import { App } from 'aws-cdk-lib';
import { Template } from 'aws-cdk-lib/assertions';
import { MultiAZWorkshopStack } from '../lib/multi-az-workshop-stack';

describe('MultiAZWorkshopStack', () => {
  test('creates VPC with correct configuration', () => {
    const app = new App();
    const stack = new MultiAZWorkshopStack(app, 'TestStack');
    const template = Template.fromStack(stack);
    
    template.hasResourceProperties('AWS::EC2::VPC', {
      EnableDnsHostnames: true,
      EnableDnsSupport: true,
    });
  });
  
  test('creates correct number of subnets', () => {
    const app = new App();
    const stack = new MultiAZWorkshopStack(app, 'TestStack');
    const template = Template.fromStack(stack);
    
    template.resourceCountIs('AWS::EC2::Subnet', 9); // 3 AZs × 3 subnet types
  });
});
```

### Snapshot Tests

**Purpose**: Detect unintended changes to synthesized CloudFormation

```typescript
test('stack matches snapshot', () => {
  const app = new App();
  const stack = new MultiAZWorkshopStack(app, 'TestStack');
  const template = Template.fromStack(stack);
  
  expect(template.toJSON()).toMatchSnapshot();
});
```

### Integration Tests

**Scope**: Verify CDK synthesis produces valid CloudFormation

```typescript
test('synthesizes without errors', () => {
  const app = new App();
  new MultiAZWorkshopStack(app, 'TestStack');
  
  expect(() => app.synth()).not.toThrow();
});
```

### Validation Tests

**Purpose**: Ensure functional equivalence with C# version

**Approach**:
1. Synthesize CloudFormation from both C# and TypeScript versions
2. Compare resource counts and types
3. Validate parameter names and defaults
4. Check output values

```typescript
test('produces same resource count as C# version', () => {
  const app = new App();
  const stack = new MultiAZWorkshopStack(app, 'TestStack');
  const template = Template.fromStack(stack);
  
  // Compare against known C# resource counts
  expect(template.resourceCountIs('AWS::EC2::VPC', 1));
  expect(template.resourceCountIs('AWS::RDS::DBCluster', 1));
  // ... more assertions
});
```

## Migration Strategy

### Git Branching Strategy

All conversion work will be performed in a dedicated feature branch to isolate changes from the main codebase.

**Branch Structure**:
- **Source Branch**: `main` (current C# implementation)
- **Feature Branch**: `feature/cdk-typescript-conversion` (all TypeScript work)
- **Target Branch**: `main` (after review and approval)

**Workflow**:
1. Create feature branch from main: `git checkout -b feature/cdk-typescript-conversion`
2. Perform all conversion work in the feature branch
3. Commit changes incrementally by phase
4. Push feature branch for review
5. Merge to main after validation and approval

**Commit Strategy**:
- One commit per major phase
- Clear commit messages describing what was converted
- Keep C# code intact until TypeScript version is validated
- Tag the last C# version before removal

### Phase 1: Project Setup
1. Create feature branch `feature/cdk-typescript-conversion`
2. Initialize Projen project
3. Configure TypeScript and CDK settings
4. Set up directory structure
5. Configure build scripts
6. Commit: "feat: initialize TypeScript CDK project with Projen"

### Phase 2: Core Infrastructure
1. Convert main stack skeleton
2. Convert type definitions and enums
3. Convert utility functions
4. Implement service factory
5. Commit: "feat: convert core infrastructure and type definitions"

### Phase 3: Constructs
1. Convert constructs in dependency order
2. Start with leaf constructs (no dependencies)
3. Progress to constructs that depend on others
4. Test each construct individually
5. Commit: "feat: convert all custom constructs to TypeScript"

### Phase 4: Nested Stacks
1. Convert nested stacks in dependency order
2. Start with foundational stacks (network, database)
3. Progress to application stacks
4. Test stack synthesis
5. Commit: "feat: convert all nested stacks to TypeScript"

### Phase 5: Integration
1. Wire all components together in main stack
2. Verify CloudFormation synthesis
3. Compare output with C# version
4. Fix any discrepancies
5. Commit: "feat: integrate all components in main stack"

### Phase 6: Build Automation
1. Create build scripts for assets
2. Implement container build process
3. Add NPX scripts for local builds
4. Document build process
5. Commit: "feat: add build automation scripts and NPX commands"

### Phase 7: Testing & Documentation
1. Write unit tests
2. Create integration tests
3. Write comprehensive README
4. Document migration notes
5. Commit: "docs: add tests and comprehensive documentation"

### Phase 8: Cleanup and Finalization
1. Remove C# CDK code from cdk/ directory
2. Update root-level documentation
3. Update GitHub workflows if needed
4. Final validation and testing
5. Commit: "chore: remove C# CDK implementation"
6. Create pull request for review

## Conversion Patterns

### C# to TypeScript Mappings

#### Property Initialization

```csharp
// C#
new StackProps() {
    StackName = "multi-az-workshop",
    Env = new Environment() {
        Region = Aws.REGION
    }
}
```

```typescript
// TypeScript
{
  stackName: 'multi-az-workshop',
  env: {
    region: process.env.CDK_DEFAULT_REGION
  }
}
```

#### String Interpolation

```csharp
// C#
$"s3://${AssetsBucketName}/${AssetsBucketPrefix}"
```

```typescript
// TypeScript
`s3://\${AssetsBucketName}/\${AssetsBucketPrefix}`
```

#### Array Initialization

```csharp
// C#
string[] zones = [
    Aws.REGION + 'a',
    Aws.REGION + 'b',
    Aws.REGION + 'c',
];
```

```typescript
// TypeScript
const zones = [
  `${cdk.Aws.REGION}a`,
  `${cdk.Aws.REGION}b`,
  `${cdk.Aws.REGION}c`,
];
```

#### Dictionary/Map

```csharp
// C#
Dictionary<string, string> map = new Dictionary<string, string>();
map.Add(key, value);
```

```typescript
// TypeScript
const map: Record<string, string> = {};
map[key] = value;
// or
const map = new Map<string, string>();
map.set(key, value);
```

#### LINQ to Array Methods

```csharp
// C#
availabilityZoneNames.Select(x => {
    string azId = azMapper.AvailabilityZoneIdFromAvailabilityZoneLetter(x.Substring(x.Length - 1));
    return azId;
}).ToArray();
```

```typescript
// TypeScript
availabilityZoneNames.map(x => {
  const azId = azMapper.availabilityZoneIdFromAvailabilityZoneLetter(x.slice(-1));
  return azId;
});
```

#### Switch Statements

```csharp
// C#
switch (evacuationMethod)
{
    case EvacuationMethod.ZonalShift:
        // code
        break;
    case EvacuationMethod.ARC:
        // code
        break;
}
```

```typescript
// TypeScript
switch (evacuationMethod) {
  case EvacuationMethod.ZONAL_SHIFT:
    // code
    break;
  case EvacuationMethod.ARC:
    // code
    break;
}
```

## Build Process

### Projen-Managed Build System

All build configuration is managed through Projen in `.projenrc.ts`. This includes:

1. **GitHub Workflows**: Defined programmatically in Projen, not as separate YAML files
2. **Local Build Tasks**: Projen tasks that mirror the GitHub workflow steps
3. **NPM Scripts**: Auto-generated from Projen task definitions

### GitHub Workflow Configuration

The GitHub workflow is defined in `.projenrc.ts` and mirrors the existing `build.yml` exactly:

```typescript
// In .projenrc.ts
const buildWorkflow = project.github?.addWorkflow("build");

buildWorkflow.on({
  pullRequest: {
    types: ["opened", "synchronize"],
    branches: ["main"],
  },
});

// Add filter job to check changed files
buildWorkflow.addJob("filter", { ... });

// Add main build job with all steps
buildWorkflow.addJob("build", {
  env: {
    CDK_LOCATION: "cdk",
    PROJECT_NAME: "${{ github.event.repository.name }}",
    HELM: "3.16.3",
    KUBECTL: "1.32.0",
    ISTIO: "1.24.1",
    // ... other versions from build/versions.json
  },
  steps: [
    // All steps from existing build.yml
  ]
});

// Add final outcome job
buildWorkflow.addJob("final", { ... });
```

### Local Build Task

A Projen task named `build:local` replicates the GitHub workflow for local development:

```typescript
// In .projenrc.ts
const buildLocal = project.addTask("build:local", {
  description: "Build project locally (mirrors GitHub workflow)",
});

// Load versions from build/versions.json
buildLocal.env("HELM", "3.16.3");
buildLocal.env("KUBECTL", "1.32.0");
buildLocal.env("ISTIO", "1.24.1");
// ... other versions

// Add all build steps
buildLocal.exec("mkdir -p tmp");
buildLocal.exec("mkdir -p assets");
buildLocal.exec("mkdir -p cdk/layer/helm");

// Download Helm and create Lambda layer
buildLocal.exec("curl --location https://get.helm.sh/helm-v$HELM-linux-arm64.tar.gz --output /tmp/helm.tar.gz");
buildLocal.exec("tar -zxvf /tmp/helm.tar.gz --directory /tmp");
buildLocal.exec("cp /tmp/linux-arm64/helm cdk/layer/helm/");
buildLocal.exec("chmod 0755 cdk/layer/helm/helm");
buildLocal.exec("cd cdk/layer && zip -r ../helm-layer.zip .");

// Copy destination rules
buildLocal.exec("cp cdk/Configs/destination-rule*.yaml assets/");

// Download kubectl
buildLocal.exec("curl --location https://dl.k8s.io/release/v$KUBECTL/bin/linux/arm64/kubectl --output assets/kubectl");

// Download Istio Helm charts
buildLocal.exec("curl --location https://istio-release.storage.googleapis.com/charts/base-$ISTIO.tgz --output assets/base-$ISTIO.tgz");
// ... other charts

// Download AWS LB controller chart
buildLocal.exec("curl --location https://aws.github.io/eks-charts/aws-load-balancer-controller-$LB_CONTROLLER_HELM.tgz --output assets/aws-load-balancer-controller-$LB_CONTROLLER_HELM.tgz");

// Pull and save Docker images
buildLocal.exec("docker pull docker.io/istio/install-cni:$ISTIO");
buildLocal.exec("docker save istio/install-cni:$ISTIO | gzip > assets/install-cni.tar.gz");
// ... other images

// Build .NET containers
buildLocal.exec("cd app-src && dotnet publish --configuration Release --runtime linux-musl-arm64 --output output/src --self-contained");
buildLocal.exec("cd app-src/output && docker build --tag multi-az-workshop:latest --platform linux/arm64 --file ../../build/dockerfile .");
buildLocal.exec("docker save multi-az-workshop:latest | gzip > assets/container.tar.gz");

// Create deployment packages
buildLocal.exec("cd assets && zip -r ../content.zip .");
buildLocal.exec("cdk synth --quiet");
buildLocal.exec("chmod +x build/package.py");
buildLocal.exec("./build/package.py multi-az-workshop . cdk");
buildLocal.exec("zip content.zip multi-az-workshop.template");
buildLocal.exec("cp content.zip assets/");
```

### Local Development Workflow

1. **Install dependencies**: `npm install` (in cdk/ directory)
2. **Build TypeScript**: `npm run build`
3. **Build all assets locally**: `npm run build:local`
4. **Run tests**: `npm test`
5. **Lint code**: `npm run lint`
6. **Synthesize CDK**: `npm run synth`
7. **Deploy**: `npm run deploy`

### Asset Build Process

The build process (both GitHub and local) follows these steps:

1. **Create directories**: tmp/, assets/, cdk/layer/helm/
2. **Download Helm binary** and create Lambda layer (helm-layer.zip)
3. **Copy destination rules** from cdk/Configs/ to assets/
4. **Download kubectl binary** to assets/
5. **Download Istio Helm charts** (base, istiod, gateway, cni) to assets/
6. **Download AWS Load Balancer Controller Helm chart** to assets/
7. **Pull and save Docker images**:
   - Istio: install-cni, proxyv2, pilot
   - AWS Load Balancer Controller
   - CloudWatch Agent
8. **Download docker-compose binary** to assets/
9. **Build .NET application** for ARM64 (if BUILD_APP=true)
10. **Build Docker containers** with .NET app
11. **Create deployment packages**:
    - app_deploy.zip (container + cloudwatch agent + docker configs)
    - app_deploy_fail.zip (failing version for testing)
12. **Synthesize CDK** and run package.py script
13. **Create content.zip** with all assets and CloudFormation template

### Generated Artifacts (Ignored in Git)

All build artifacts are ignored in `.gitignore`:

```
assets/**/*
cdk/helm-layer.zip
cdk/layer/
tmp/
app-src/output/
content.zip
*.tar.gz
```

### NPX Scripts

Scripts are auto-generated by Projen from task definitions:

```json
{
  "scripts": {
    "build": "npx projen build",
    "build:local": "npx projen build:local",
    "synth:local": "npx projen synth:local",
    "deploy:local": "npx projen deploy:local",
    "test:unit": "npx projen test:unit",
    "test:coverage": "npx projen test:coverage",
    "lint": "npx projen eslint",
    "lint:fix": "npx projen lint:fix"
  }
}
```

## Documentation Requirements

### README.md

Must include:
1. Project overview and purpose
2. Prerequisites (Node.js, AWS CLI, Docker, .NET SDK)
3. Installation instructions
4. Build process documentation
5. Deployment instructions
6. Testing instructions
7. Project structure explanation
8. Troubleshooting guide

### Inline Documentation

- JSDoc comments for all public classes and methods
- Explanation of complex logic
- References to C# source for comparison
- Notes on TypeScript-specific patterns

### Migration Notes

Document in `MIGRATION.md`:
1. Key differences between C# and TypeScript implementations
2. Naming convention changes
3. Type system differences
4. Build process changes
5. Known issues or limitations

## Dependencies

### CDK Libraries

```json
{
  "dependencies": {
    "aws-cdk-lib": "2.189.1",
    "cdklabs.multi-az-observability": "0.0.1-alpha.60",
    "@aws-cdk/lambda-layer-kubectl-v31": "^2.0.0",
    "constructs": "^10.4.2"
  }
}
```

### Development Dependencies

```json
{
  "devDependencies": {
    "@types/node": "^20.x",
    "@types/jest": "^29.x",
    "jest": "^29.x",
    "ts-jest": "^29.x",
    "typescript": "^5.x",
    "eslint": "^8.x",
    "@typescript-eslint/eslint-plugin": "^6.x",
    "@typescript-eslint/parser": "^6.x",
    "aws-cdk": "2.189.1",
    "projen": "^0.x"
  }
}
```

## Validation Criteria

### Functional Equivalence

1. **CloudFormation Template Comparison**
   - Same resource types and counts
   - Identical parameter names and defaults
   - Matching output values
   - Equivalent resource properties

2. **Deployment Verification**
   - Successful stack creation
   - All resources created correctly
   - No drift from C# version
   - Same runtime behavior

3. **Build Process Validation**
   - All assets generated correctly
   - Container images built successfully
   - Lambda layers created properly
   - Deployment packages complete

### Code Quality

1. **TypeScript Compilation**
   - No compilation errors
   - Strict mode enabled
   - All types properly defined

2. **Linting**
   - No ESLint errors
   - Consistent code style
   - Best practices followed

3. **Testing**
   - All unit tests passing
   - Integration tests successful
   - Snapshot tests stable

## Risk Mitigation

### Potential Issues

1. **CDK API Differences**: C# and TypeScript CDK APIs may have subtle differences
   - **Mitigation**: Carefully review CDK documentation for both languages
   - **Mitigation**: Test each construct individually

2. **Type System Differences**: C# and TypeScript have different type systems
   - **Mitigation**: Use strict TypeScript mode
   - **Mitigation**: Define explicit interfaces

3. **Build Process Complexity**: Asset building involves multiple tools and platforms
   - **Mitigation**: Create modular build scripts
   - **Mitigation**: Document each build step thoroughly

4. **Path Resolution**: File paths may behave differently across platforms
   - **Mitigation**: Use Node.js path module
   - **Mitigation**: Test on multiple platforms

5. **Async Operations**: TypeScript may require async/await where C# doesn't
   - **Mitigation**: Identify async operations early
   - **Mitigation**: Use proper async patterns

## Success Metrics

1. **Functional Equivalence**: CloudFormation templates are functionally identical
2. **Build Success**: All build scripts execute without errors
3. **Test Coverage**: >80% code coverage with unit tests
4. **Documentation**: Complete README and migration guide
5. **Deployment**: Successful deployment to AWS environment
6. **Performance**: Synthesis time comparable to C# version
