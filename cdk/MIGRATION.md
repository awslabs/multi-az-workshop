# Migration Guide: C# to TypeScript CDK

This document outlines the key differences between the C# and TypeScript implementations of the Multi-AZ Workshop CDK project, and provides guidance for developers working with the TypeScript version.

## Overview

The Multi-AZ Workshop CDK project has been converted from C# to TypeScript while maintaining 100% functional equivalence. This migration preserves all infrastructure resources, configurations, and behaviors while adopting TypeScript idioms and best practices.

## Key Differences

### 1. Project Structure

#### C# Structure
```
cdk/
├── Program.cs                    # Entry point
├── MultiAZWorkshopStack.cs       # Main stack
├── Constructs/                   # Custom constructs
├── NestedStacks/                 # Nested stacks
├── EvacuationMethod.cs           # Enum definition
└── multi-az-workshop-cdk.csproj  # Project file
```

#### TypeScript Structure
```
cdk/
├── src/
│   └── main.ts                   # Entry point (Projen-managed)
├── lib/
│   ├── multi-az-workshop-stack.ts
│   ├── constructs/               # Custom constructs
│   ├── nested-stacks/            # Nested stacks
│   ├── types/                    # Type definitions
│   └── utils/                    # Utility functions
├── .projenrc.ts                  # Projen configuration
└── package.json                  # Generated by Projen
```

**Key Changes:**
- Entry point moved from `Program.cs` to `src/main.ts`
- Stack and construct code organized under `lib/` directory
- Type definitions separated into `lib/types/`
- Utility functions extracted to `lib/utils/`
- Project configuration managed by Projen instead of `.csproj`

### 2. Naming Conventions

#### C# (PascalCase)
```csharp
public class MultiAZWorkshopStack : Stack
{
    private readonly EvacuationMethod evacuationMethod;
    
    public void CreateResources()
    {
        var loadBalancer = new ApplicationLoadBalancer(this, "alb", new ApplicationLoadBalancerProps
        {
            InternetFacing = false,
            Vpc = networkStack.Vpc
        });
    }
}
```

#### TypeScript (camelCase for variables, PascalCase for classes)
```typescript
export class MultiAZWorkshopStack extends cdk.Stack {
  private readonly evacuationMethod: EvacuationMethod;
  
  private createResources(): void {
    const loadBalancer = new elbv2.ApplicationLoadBalancer(this, 'alb', {
      internetFacing: false,
      vpc: this.networkStack.vpc,
    });
  }
}
```

**Key Changes:**
- Class names remain PascalCase
- Variables and properties use camelCase
- Method names use camelCase
- Property names in object literals use camelCase

### 3. Type System Differences

#### Enums

**C#:**
```csharp
public enum EvacuationMethod
{
    ZonalShift,
    ARC,
    SelfManagedHttpEndpoint_APIG,
    SelfManagedHttpEndpoint_S3
}
```

**TypeScript:**
```typescript
export enum EvacuationMethod {
  ZonalShift = 'ZonalShift',
  ARC = 'ARC',
  SelfManagedHttpEndpoint_APIG = 'SelfManagedHttpEndpoint_APIG',
  SelfManagedHttpEndpoint_S3 = 'SelfManagedHttpEndpoint_S3',
}
```

**Key Changes:**
- TypeScript enums require explicit string values for string enums
- Enum members use PascalCase in both languages

#### Interfaces and Props

**C#:**
```csharp
public interface IMultiAZWorkshopStackProps : IStackProps
{
    // Properties
}

new MultiAZWorkshopStack(app, "stack", new StackProps() {
    StackName = "multi-az-workshop",
    Env = new Environment() {
        Region = Aws.REGION
    }
});
```

**TypeScript:**
```typescript
export interface MultiAZWorkshopStackProps extends cdk.StackProps {
  // Properties
}

new MultiAZWorkshopStack(app, 'stack', {
  stackName: 'multi-az-workshop',
  env: {
    region: process.env.CDK_DEFAULT_REGION,
  },
});
```

**Key Changes:**
- Interface names don't require `I` prefix in TypeScript (though it's optional)
- Object initialization uses object literals instead of `new` keyword
- Property names use camelCase

#### Nullable Types

**C#:**
```csharp
public string? OptionalProperty { get; set; }
public IApplicationTargetGroup[]? TargetGroups { get; set; }
```

**TypeScript:**
```typescript
public readonly optionalProperty?: string;
public readonly targetGroups?: elbv2.IApplicationTargetGroup[];
```

**Key Changes:**
- TypeScript uses `?` suffix for optional properties
- TypeScript uses `readonly` for immutable properties

### 4. Language Syntax Differences

#### String Interpolation

**C#:**
```csharp
string path = $"s3://{AssetsBucketName}/{AssetsBucketPrefix}";
string azName = $"{Aws.REGION}a";
```

**TypeScript:**
```typescript
const path = `s3://\${AssetsBucketName}/\${AssetsBucketPrefix}`;
const azName = `${cdk.Aws.REGION}a`;
```

**Key Changes:**
- TypeScript uses backticks for template literals
- Variables in templates use `${variable}` syntax
- CloudFormation pseudo-parameters need escaping: `\${}`

#### Collections

**C#:**
```csharp
// Arrays
string[] zones = new string[] { "us-east-1a", "us-east-1b", "us-east-1c" };

// Dictionaries
Dictionary<string, string> map = new Dictionary<string, string>();
map.Add(key, value);

// LINQ
var azIds = availabilityZoneNames.Select(x => {
    string azId = azMapper.AvailabilityZoneIdFromAvailabilityZoneLetter(x.Substring(x.Length - 1));
    return azId;
}).ToArray();
```

**TypeScript:**
```typescript
// Arrays
const zones: string[] = ['us-east-1a', 'us-east-1b', 'us-east-1c'];

// Objects/Records
const map: Record<string, string> = {};
map[key] = value;

// Or Map
const map = new Map<string, string>();
map.set(key, value);

// Array methods (similar to LINQ)
const azIds = availabilityZoneNames.map(x => {
  const azId = azMapper.availabilityZoneIdFromAvailabilityZoneLetter(x.slice(-1));
  return azId;
});
```

**Key Changes:**
- Array literals use `[]` syntax
- `Dictionary<K,V>` becomes `Record<K,V>` or `Map<K,V>`
- LINQ methods map to array methods: `Select` → `map`, `Where` → `filter`, `ToArray()` not needed

#### Switch Statements

**C#:**
```csharp
switch (evacuationMethod)
{
    case EvacuationMethod.ZonalShift:
        // code
        break;
    case EvacuationMethod.ARC:
        // code
        break;
    default:
        break;
}
```

**TypeScript:**
```typescript
switch (evacuationMethod) {
  case EvacuationMethod.ZonalShift:
    // code
    break;
  case EvacuationMethod.ARC:
    // code
    break;
  default:
    break;
}
```

**Key Changes:**
- Syntax is nearly identical
- Braces placement follows JavaScript conventions

### 5. CDK API Differences

#### Resource Creation

**C#:**
```csharp
var logGroup = new LogGroup(this, "log-group", new LogGroupProps
{
    LogGroupName = "/my-app/logs",
    Retention = RetentionDays.ONE_WEEK,
    RemovalPolicy = RemovalPolicy.DESTROY
});
```

**TypeScript:**
```typescript
const logGroup = new logs.LogGroup(this, 'log-group', {
  logGroupName: '/my-app/logs',
  retention: logs.RetentionDays.ONE_WEEK,
  removalPolicy: cdk.RemovalPolicy.DESTROY,
});
```

**Key Changes:**
- Import namespaces explicitly: `import * as logs from 'aws-cdk-lib/aws-logs'`
- Use namespace prefixes: `logs.LogGroup`, `logs.RetentionDays`
- Props passed as object literals

#### CloudFormation Functions

**C#:**
```csharp
Fn.Sub("${AWS::Region}")
Fn.Join(".", new string[] { "a", "b", "c" })
Fn.Select(0, vpc.VpcIpv6CidrBlocks)
```

**TypeScript:**
```typescript
cdk.Fn.sub('${AWS::Region}')
cdk.Fn.join('.', ['a', 'b', 'c'])
cdk.Fn.select(0, vpc.vpcIpv6CidrBlocks)
```

**Key Changes:**
- Access through `cdk.Fn` namespace
- Method names use camelCase
- Array literals instead of `new string[]`

### 6. Build Process Changes

#### C# Build Process
```bash
# Restore dependencies
dotnet restore

# Build project
dotnet build

# Synthesize CDK
cdk synth
```

#### TypeScript Build Process
```bash
# Install dependencies
npm install

# Build TypeScript
npm run build

# Synthesize CDK
npm run cdk:synth

# Or use Projen tasks
npx projen build
npx projen cdk:synth
```

**Key Changes:**
- `npm` replaces `dotnet` for package management
- Projen manages build configuration
- Build scripts defined in `package.json` (generated by Projen)
- TypeScript compilation happens before CDK synthesis

### 7. Testing Differences

#### C# Testing
```csharp
using Xunit;
using Amazon.CDK;
using Amazon.CDK.Assertions;

public class StackTests
{
    [Fact]
    public void TestVPCCreation()
    {
        var app = new App();
        var stack = new MultiAZWorkshopStack(app, "test");
        var template = Template.FromStack(stack);
        
        template.HasResourceProperties("AWS::EC2::VPC", new Dictionary<string, object>
        {
            { "EnableDnsHostnames", true }
        });
    }
}
```

#### TypeScript Testing
```typescript
import { App } from 'aws-cdk-lib';
import { Template } from 'aws-cdk-lib/assertions';
import { MultiAZWorkshopStack } from '../lib/multi-az-workshop-stack';

describe('StackTests', () => {
  test('TestVPCCreation', () => {
    const app = new App();
    const stack = new MultiAZWorkshopStack(app, 'test', {});
    const template = Template.fromStack(stack);
    
    template.hasResourceProperties('AWS::EC2::VPC', {
      EnableDnsHostnames: true,
    });
  });
});
```

**Key Changes:**
- Jest replaces xUnit
- `describe` and `test` instead of classes and `[Fact]`
- Method names use camelCase: `FromStack` → `fromStack`
- Object literals for expected properties

### 8. Dependency Management

#### C# Dependencies (.csproj)
```xml
<PackageReference Include="Amazon.CDK.Lib" Version="2.189.1" />
<PackageReference Include="Cdklabs.MultiAzObservability" Version="0.0.1-alpha.60" />
```

#### TypeScript Dependencies (package.json)
```json
{
  "dependencies": {
    "aws-cdk-lib": "2.189.1",
    "@cdklabs/multi-az-observability": "0.0.1-alpha.60"
  }
}
```

**Key Changes:**
- `package.json` replaces `.csproj`
- Package names use npm conventions (scoped packages with `@`)
- Managed by Projen through `.projenrc.ts`

### 9. File Paths and Asset References

#### C# Path Handling
```csharp
string configPath = Path.Combine(__dirname, "..", "Configs", "cw-agent-config.json");
```

#### TypeScript Path Handling
```typescript
import * as path from 'path';

const configPath = path.join(__dirname, '..', 'Configs', 'cw-agent-config.json');
```

**Key Changes:**
- Import Node.js `path` module
- Use `path.join()` for cross-platform compatibility
- `__dirname` available in both (Node.js global)

## Known Issues and Limitations

### 1. Projen-Managed Files

**Issue:** Files generated by Projen (like `package.json`, `tsconfig.json`) should not be edited directly.

**Solution:** Make changes in `.projenrc.ts` and run `npx projen` to regenerate files.

### 2. Asset Path Resolution

**Issue:** Asset paths must be resolved relative to the compiled JavaScript location, not the TypeScript source.

**Solution:** Use `__dirname` and `path.join()` to construct paths dynamically:
```typescript
const assetPath = path.join(__dirname, '..', 'Configs', 'config.json');
```

### 3. Type Strictness

**Issue:** TypeScript strict mode may catch issues that C# didn't flag.

**Solution:** Address type errors explicitly. Use type assertions sparingly:
```typescript
const value = someValue as string; // Use only when necessary
```

### 4. Async/Await

**Issue:** Some CDK operations that were synchronous in C# may be async in TypeScript.

**Solution:** Use `async/await` where needed:
```typescript
async function deployStack() {
  await stack.deploy();
}
```

### 5. CloudFormation Pseudo-Parameters

**Issue:** CloudFormation pseudo-parameters need escaping in template literals.

**Solution:** Use `\${}` for CloudFormation parameters:
```typescript
const value = cdk.Fn.sub('s3://\${BucketName}/\${Prefix}');
```

## Migration Checklist

When working with the TypeScript version:

- [ ] Use `npm install` instead of `dotnet restore`
- [ ] Run `npm run build` to compile TypeScript
- [ ] Use `npx projen` to regenerate Projen-managed files
- [ ] Follow camelCase naming for variables and methods
- [ ] Use object literals for props instead of `new` keyword
- [ ] Import CDK modules explicitly: `import * as ec2 from 'aws-cdk-lib/aws-ec2'`
- [ ] Use template literals with backticks for string interpolation
- [ ] Use array methods (`map`, `filter`) instead of LINQ
- [ ] Write tests with Jest instead of xUnit
- [ ] Use `path.join()` for file path construction

## Additional Resources

- [AWS CDK TypeScript Workshop](https://cdkworkshop.com/20-typescript.html)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [Projen Documentation](https://projen.io/)
- [Jest Testing Framework](https://jestjs.io/docs/getting-started)

## Getting Help

If you encounter issues during migration or development:

1. Check the TypeScript compiler errors: `npm run build`
2. Review CDK synthesis output: `npm run cdk:synth`
3. Compare with C# implementation in `cdk-csharp-backup/` directory
4. Consult AWS CDK TypeScript API documentation
5. Review this migration guide for common patterns

